# Java虚拟机
## 1、JVM执行流程
JVM执行流程分为两个部分，分别是编译时环境和运行时环境，当一个Java文件经过Java编译后会生成Class文件，这个Class文件由JVM处理。JVM和Java语言没有必然的联系，只与特定的二进制文件：Class文件有关。任何语言只要能编译成Class文件，都可以被JVM识别执行，包括Java、Kotlin、Groovy等等。

## 2、JVM结构
JVM结构分为`运行时数据区域`、`执行引擎`、`本地库接口`和`本地方法库`，类加载子系统不属于JVM的内部结构。

运行时数据区域包括Java堆、Java栈、本地方法栈、方法区、程序计数器，其中Java堆和方法区是所有线程共享的数据区域。

### 2.1 Class文件格式
每个Class文件中都对应唯一的类或接口信息，但是类或者接口并不一定定义在文件中，比如类和接口可以通过类加载器直接生成。

```java
ClassFile {
	// 魔数，用来判断当前文件是不是能被JVM处理的Class文件
	u4 magic; 
	// 副版本号
	u2 minor_version;
	// 主版本号
	u2 major_version;
	// 常量池计数器
	u2 constant_pool_count;
	// 常量池
	cp_info constant_pool[constant_pool_count-1]
	// 类和接口层次的访问标识
	u2 access_flags;
	// 类索引
	u2 this_class;
	// 父类索引
	u2 super_class;
	// 接口计数器
	u2 interfaces_count;
	// 接口表
	u2 interfaces[interfaces_count];
	// 字段计数器
	u2 fields_count;
	// 字段表
	field_info fields[fields_count];
	// 方法计数器
	u2 methods_count;
	// 方法表
	method_info methods[methods_count];
	// 属性计数器
	u2 attributes_count;
	// 属性表
	attribute_info attributes[attributes_count];
}
```

### 2.2 类的生命周期
类的生命周期包括的阶段分别是：`加载`、`链接`、`初始化`、`使用`和`卸载`，其中链接包括三个阶段：`验证`、`准备`和`解析`。

（1）加载：查找并加载Class文件。

- 根据特定名称查找类或接口类型的二进制字节流。
- 将这个二进制字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

（2）链接：包括验证、准备和解析。

- 验证：确保被导入类型的正确性。
- 准备：为类的静态字段分配字段，并用默认值初始化这些字段。
- 解析：虚拟机将常量池内的符号引用转化为直接引用。

（3）初始化：将类变量初始化为正确初始值。

### 2.3 类加载子系统
JVM有两种类加载器：系统加载器和自定义加载器，系统加载器包括三种：

- Bootstrap ClassLoader（引导类加载器）：用于加载指定的JDK核心类库
- Extensions ClassLoader（扩展类加载器）：用于加载Java扩展类
- Application ClassLoader（应用程序类加载器）：用于加载应用程序目录和系统属性java.class.path指定的目录

### 2.4 运行时数据区域
#### 2.4.1 程序计数器
程序计数器也叫PC寄存器，是一块较小的内存空间。在虚拟机概念模型中，字节码解释器工作时就是通过改变程序计数器来选取下一条需要执行的字节码指令。

程序计数器是线程是有的，每个线程都会有一个独立的程序计数器。

如果线程执行的方法是Native方法，则程序计数器的值为空；如果是Java方法，则程序计数器保存正在执行的字节码指令地址。程序计数器是JVM规范中唯一没有规定OOM情况的数据区域。

#### 2.4.2 Java虚拟机栈
每一条JVM线程都有一个线程私有的Java虚拟机栈，它的生命周期与线程相同。Java虚拟机栈存储线程中Java方法调用的状态，包括局部变量、参数、返回值以及运算的中间结果等。当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java虚拟机栈中，在该方法执行完成后，这个栈帧从Java虚拟机栈中弹出。

#### 2.4.3 本地方法栈
和Java虚拟机栈类似，只不过用来支持Native方法。

#### 2.4.4 Java堆
Java堆用来存放对象实例，几乎所有的对象实例都在这里分配内存。

#### 2.4.5 方法区
方法区用来存储已经被JVM加载的类的结构信息，包括运行时常量池、字段、静态变量和方法信息等数据。

常量池用来存放编译时期生成的字面量和符号引用，这些内容会在类加载后存放在方法区的运行时常量池中，运行时常量池可以理解为类或接口的常量池的运行时表现形式。

## 3、对象的创建
### 3.1 判断对象对应的类是否加载、链接和初始化
JVM收到一条new指令时，首先会去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用是否已被类加载器加载、链接和初始化。

### 3.2 为对象分配内存
类加载完成后，会在Java堆中划分一块内存分配给对象。内存分配根据Java堆是否规整，有两种方式。

- 指针碰撞：如果Java堆的内存是规整的，分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离。
- 空闲列表：如果Java堆的内存不是规整的，则需要由JVM维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。

### 3.3 处理并发安全问题
- 对分配内存空间的动作进行不同处理。
- 每个线程在Java堆中预先分配一小块内存，这块内存称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），线程需要分配内存时，就在对应线程的TLAB上分配内存，当线程中的TLAB用完并且被分配到新的TLAB时，才需要同步锁定。

### 3.4 初始化分配到的内存空间
将分配的内存，除了对象头外都初始化为零值。

### 3.5 设置对象的对象头
将对象的所属类、对象的HashCode和对象的GC分代年龄等数据存储在对象的对象头中。

### 3.6 执行init方法进行初始化
执行init方法，初始化对象的成员变量、调用类的构造方法，这样一个对象就创建出来了。

## 4、对象的堆内存布局
对象在堆内存中的布局分为三个区域，分别是`对象头`、`实例数据`、`对象填充`。

- 对象头：包括两部分信息，分别是`Mark Word`和`元数据指针`。Mark Word用于存储对象运行时的数据，比如HashCode、锁状态标志、GC分代年龄、线程持有的锁等。而元数据指针用于指向方法区中的目标类的元数据，通过元数据可以确定对象的具体类型。
- 实例数据：用于存储对象中的各种类型的字段信息。
- 对齐填充：对齐填充不一定存在，起到了占位符的作用。

## 5、oop-kclass模型
oop-kclass模型用来描述对象实例的一种模型，分为oop和kclass两个部分。oop（Ordinary Object Pointer）指的是普通对象指针，用来表示对象的实例信息。klass用来描述元数据。

oop是一个家族，JVM内部oopsHierarchy.hpp定义很多oop类型，其中oopDesc是所有oop的顶级父类，arrayOopDesc是objArrayOopDesc和typeArrayOopDesc的父类。

Klass是klass家族的父类（不是顶级父类），ArrayKlass是ObjArrayKlass和TypeArrayKlass的父类。klass描述了Java类在JVM中对等的C++类型。

JVM通过栈帧中的对象引用找到Java堆中的instanceOopDesc，这样就可以访问到Java对象的实例信息，当需要访问对象的具体类型等信息时，可以通过instanceOopDesc中的元数据指针找到方法区中对应的instanceKlass。
